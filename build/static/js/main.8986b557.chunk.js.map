{"version":3,"sources":["const.js","classes/biome.js","biomes.js","classes/monster.js","monsters.js","utils.js","classes/hero.js","heroes.js","components/turn-hero.js","components/biome-matrix.js","components/monster-matrix.js","components/turnPhaseFailureRecord.js","components/turnPhaseShiftSpellUsed.js","components/turnPhaseRuneUsed.js","components/turn.js","monsters-on-biomes.js","competitive-mode.js","App.js","index.js"],"names":["SHIFT_SCROLL","HEAL_POTION","RUNE","MONSTER","Biome","name","type","matrix","this","biomesArray","math","Monster","strength","forEach","value","monstersArray","randomWeighted","prob","i","sum","r","Math","random","Number","randomInt","int","floor","getSpellTypeCount","spells","spellType","filter","x","length","getSpellsCountsDiffByType","heroSpells","monsterSpells","runesCount","saveSpellsComparisonFailureRecord","monsterSpellsOnBiome","getSpellsCountsDiffByTypeY","getSpellsCountsDiffByTypeB","getSpellsCountsDiffByTypeG","getSpellsCountsDiffByTypeR","spell","diff","abs","checkSpellsComparisonSuccessByType","runes","runesByType","find","runesByTypeCount","shiftMatrix","shift","result","shiftFailed","index","y","valueOf","subset","getOpositeShiftDirection","shiftSpell","JSON","stringify","getSpellByShiftDirection","getOptimalShiftSpellDirection","prevFightResult","hero","failureRecord","nonFailedSpells","map","nonFailedSpellsExcludingPrevShift","opositeShiftDirection","previousSpell","s","excludeSpellsFomPrevShiftDirection","spellsNotReachedLimitInCurrentTest","v","includes","push","getSpellsNotReachedLimitInCurrentTest","validSpellsToUse","heroStrongestSpell","getStrongestSpell","getShiftDirectionBySpell","pop","getCurrentHeroStatus","shiftSpellScrollsLeft","shiftSpellScrolls","healPotionsLeft","healPotions","getSpells","strongestSpell","runesLeft","fightWithMonster","monster","biome","biomeMatrix","mask","monsterSpellsMatrixOnBiome","get","applyMask","activeSpells","getMonsterSpellsOnBiome","fightResult","compareSpellsCountsByTypeY","compareSpellsCountsByTypeB","compareSpellsCountsByTypeG","compareSpellsCountsByTypeR","isComparisonSuccess","isSuccess","sort","usedRunes","compareSpellsCounts","heroStatus","getFailedSpellsCount","getFailedSpells","reduce","acc","fail","fightWithMonsterUsingSpells","isTestCheck","useShiftSpellScroll","shiftSpellWasUsed","fightWithMonsterUsingSpellsChooseDirection","fightWithMonsterUsingSpellsTestAllDirections","fightWithMonsterUsingSpellsTestOptimalDirection","optimalShiftSpellDirection","getMonsterWithShiftedMatrix","attackMonster","turnRecord","currentMonster","phases","failedSpells","failedSpellsTotalCount","useRunes","runesWasUsed","fightWithMonsterUsingRunes","addMonsterTrophy","hit","heroTurn","key","currentEncounter","findShiftScroll","addShiftSpellScroll","findHealPotion","addHealPotion","findRune","addRune","Hero","slice","monsterTrophies","a","b","num","newScrolls","addRandomSpell","runesUsedCount","useHealPotion","removeRandomSpell","spellIndex","splice","possibleSpells","missedSpells","getStrength","getMonsterTrophiesPoints","treasureGift","heroesArray","TurnHero","className","getMonsterTrophiesCount","getTotalPoints","BiomeMatrix","biomeArr","spellsRow","MonsterMatrix","monsterArr","TurnPhaseFailureRecord","TurnPhaseShiftSpellUsed","getCurrentShiftSpellFromArray","TurnPhaseRuneUsed","Turn","phase","turnRecords","window","turnRecordsMonstersOnBiomes","console","log","turnRecordsByMonsters","turn","biomeName","monsterName","MonstersOnBiomes","Object","entries","biomes","heroes","outsider","outsiderHero","getMonsterTrophiesCountOutsiderHero","leaderHero","leader","getMonsterTrophiesCountLeaderHero","giveRandomTreasure","prefferableBiomeType","prefferableBiome","randomBiome","currentBiome","turnRecordsByHero","CompetitiveMode","Array","isArray","turnRecordInner","App","useState","showMonstersOnBiomes","setShowMonstersOnBiomes","checked","onChange","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.8986b557.chunk.js","sourcesContent":["export const Y = 1;\nexport const B = 2;\nexport const G = 3;\nexport const R = 4;\n\nexport const SHIFT_SCROLL = 'shift scroll';\nexport const HEAL_POTION = 'heal potion';\nexport const RUNE = 'rune';\nexport const MONSTER = 'monster';","export default class Biome {\n  constructor(name, type, matrix) {\n    this.name = name;\n    this.matrix = matrix;\n    this.type = type;\n  }\n}","import * as math from 'mathjs';\nimport { Y, B, G, R } from './const';\nimport Biome from './classes/biome';\n\nexport const biome1 = new Biome(\"Desert\", Y, math.matrix([\n  [R,Y,Y,Y,Y,Y,Y],\n  [R,Y,Y,Y,Y,Y,Y],\n  [R,R,Y,Y,Y,B,B],\n  [R,R,R,Y,B,B,B],\n  [R,R,R,G,B,B,B],\n  [R,R,G,G,G,B,B],\n  [G,G,G,G,G,G,B],\n]));\n\nexport const biome2 = new Biome(\"River\", B, math.matrix([\n  [Y,Y,Y,Y,Y,Y,Y],\n  [R,Y,Y,Y,Y,B,B],\n  [R,Y,Y,Y,B,B,B],\n  [R,R,R,B,B,B,B],\n  [R,R,G,G,B,B,B],\n  [R,G,G,G,B,B,B],\n  [G,G,G,G,G,G,B],\n]));\n\nexport const biome3 = new Biome(\"Forest\", G, math.matrix([\n  [Y,Y,Y,Y,Y,Y,Y],\n  [R,Y,Y,Y,Y,B,B],\n  [R,R,R,Y,B,B,B],\n  [R,R,R,G,B,B,B],\n  [R,G,G,G,B,B,B],\n  [G,G,G,G,G,G,B],\n  [G,G,G,G,G,G,B],\n]));\n\nexport const biome4 = new Biome(\"Fireland\", R, math.matrix([\n  [R,Y,Y,Y,Y,Y,Y],\n  [R,R,Y,Y,Y,Y,B],\n  [R,R,R,Y,Y,B,B],\n  [R,R,R,R,B,B,B],\n  [R,R,R,G,G,B,B],\n  [R,R,R,G,G,B,B],\n  [G,G,G,G,G,G,B],\n]));\n\nexport const biomesArray = [biome1, biome2, biome3, biome4];\n","export default class Monster {\n  constructor(name, matrix) {\n    this.name = name;\n    this.matrix = matrix;\n  }\n\n  getStrength() {\n    let strength = 0;\n    this.matrix.forEach(value => {\n      if (value) {\n        strength++;\n      }\n    });\n    return strength;\n  }\n}","import * as math from 'mathjs';\n\nimport Monster from './classes/monster';\n\nexport const monster1 = new Monster(\"Flower bird\", math.matrix([\n  [0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0],\n  [0,0,0,1,1,1,0],\n  [0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0],\n]));\n\nexport const monster2 = new Monster(\"Fire ball\", math.matrix([\n  [0,0,0,0,0,0,0],\n  [0,0,1,0,0,0,0],\n  [0,0,1,0,0,0,0],\n  [0,0,1,0,0,0,0],\n  [0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0],\n]));\n\nexport const monster3 = new Monster(\"Ktulhu guard\", math.matrix([\n  [0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0],\n  [0,0,0,1,1,1,0],\n  [0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0],\n]));\n\nexport const monster4 = new Monster(\"Fat imp\", math.matrix([\n  [0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0],\n  [0,0,0,1,1,0,0],\n  [0,0,0,1,1,0,0],\n  [0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0],\n]));\n\nexport const monster5 = new Monster(\"Big foot\", math.matrix([\n  [0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0],\n  [0,1,1,1,0,0,0],\n  [0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0],\n]));\n\nexport const monster6 = new Monster(\"Furry\", math.matrix([\n  [0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0],\n  [0,0,1,1,0,0,0],\n  [0,0,1,1,0,0,0],\n  [0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0],\n]));\n\n\nexport const monstersArray = [monster1, monster2, monster3, monster4, monster5, monster6];\n","import * as math from 'mathjs';\nimport { Y, B, G, R } from './const';\nimport { SHIFT_SCROLL, HEAL_POTION, RUNE, MONSTER } from './const';\nimport { monstersArray } from './monsters';\n\nexport const randomWeighted = prob => {\n  let i, sum=0, r=Math.random();\n  for (i in prob) {\n    sum += prob[i];\n    if (r <= sum) return Number(i);\n  }\n}\n\nexport const randomInt = int => Math.floor(Math.random()) * int;\n\nexport const getSpellTypeCount = (spells, spellType) => spells.filter(x=> x === spellType).length;\n\nexport const getSpellsCountsDiffByType = (heroSpells, monsterSpells, spellType, runesCount = 0) => getSpellTypeCount(heroSpells, spellType) - getSpellTypeCount(monsterSpells, spellType) + runesCount;\n\nexport const saveSpellsComparisonFailureRecord = (heroSpells, monsterSpellsOnBiome) => {\n  const getSpellsCountsDiffByTypeY = getSpellsCountsDiffByType(heroSpells, monsterSpellsOnBiome, Y);\n  const getSpellsCountsDiffByTypeB = getSpellsCountsDiffByType(heroSpells, monsterSpellsOnBiome, B);\n  const getSpellsCountsDiffByTypeG = getSpellsCountsDiffByType(heroSpells, monsterSpellsOnBiome, G);\n  const getSpellsCountsDiffByTypeR = getSpellsCountsDiffByType(heroSpells, monsterSpellsOnBiome, R);\n\n  const spellComparisonFailureRecord = [\n    {spell: Y, diff: getSpellsCountsDiffByTypeY < 0 ? Math.abs(getSpellsCountsDiffByTypeY) : 0},\n    {spell: B, diff: getSpellsCountsDiffByTypeB < 0 ? Math.abs(getSpellsCountsDiffByTypeB) : 0},\n    {spell: G, diff: getSpellsCountsDiffByTypeG < 0 ? Math.abs(getSpellsCountsDiffByTypeG) : 0},\n    {spell: R, diff: getSpellsCountsDiffByTypeR < 0 ? Math.abs(getSpellsCountsDiffByTypeR) : 0},\n  ];\n\n  // spellComparisonFailuresArray.push(spellComparisonFailureRecord);\n  return spellComparisonFailureRecord;\n}\n\nexport const checkSpellsComparisonSuccessByType = (heroSpells, monsterSpells, spellType, runes = []) => {\n  const runesByType = runes.find(x=>x.spell === spellType) || {};\n  const runesByTypeCount = runesByType.diff || 0;\n  return getSpellsCountsDiffByType(heroSpells, monsterSpells, spellType, runesByTypeCount) >= 0;\n}\n\n// matrix - math.js matrix, shift - array with shift direction [1,0], [0, -1], ... etc.\nexport const shiftMatrix = (matrix, shift) => {\n  let result = math.zeros(math.size(matrix));\n  let shiftFailed = false;\n\n  matrix.forEach((value, index) => {\n    if (value) {\n      const y = index[0] + shift[0];\n      const x = index[1] + shift[1];\n\n      if (y < 0 || y >= math.size(result).valueOf()[0]) {\n        shiftFailed = true;\n        return false;\n      }\n\n      if (x < 0 || x >= math.size(result).valueOf()[1]) {\n        shiftFailed = true;\n        return false;\n      }\n      result.subset(math.index(y,x),1);\n    }\n  });\n\n  if (shiftFailed) {\n    result = matrix;\n  }\n\n  return result;\n};\n\nexport const applyMask = (biome, mask) => biome.map((value, index) => value * mask.get(index));\n\nexport const compareSpellsCounts = (heroSpells, monsterSpellsOnBiome, runes) => {\n  // let unusedRunes = [...runes];\n  const compareSpellsCountsByTypeY = checkSpellsComparisonSuccessByType(heroSpells, monsterSpellsOnBiome, Y, runes);\n  const compareSpellsCountsByTypeB = checkSpellsComparisonSuccessByType(heroSpells, monsterSpellsOnBiome, B, runes);\n  const compareSpellsCountsByTypeG = checkSpellsComparisonSuccessByType(heroSpells, monsterSpellsOnBiome, G, runes);\n  const compareSpellsCountsByTypeR = checkSpellsComparisonSuccessByType(heroSpells, monsterSpellsOnBiome, R, runes);\n\n  const isComparisonSuccess = compareSpellsCountsByTypeY\n                              && compareSpellsCountsByTypeB\n                              && compareSpellsCountsByTypeG\n                              && compareSpellsCountsByTypeR;\n\n  return {\n    isSuccess: isComparisonSuccess,\n    failureRecord: !isComparisonSuccess && saveSpellsComparisonFailureRecord(heroSpells, monsterSpellsOnBiome),\n    monsterSpellsOnBiome: monsterSpellsOnBiome.sort(),\n    usedRunes: runes\n  };  \n}\n\nexport const getMonsterSpellsOnBiome = (biomeMatrix, mask, shift) => {\n  if (shift) {\n    mask = shiftMatrix(mask, shift);\n  }\n  const monsterSpellsMatrixOnBiome = applyMask(biomeMatrix, mask);\n  const activeSpells = [];\n  monsterSpellsMatrixOnBiome.forEach(value => {\n    if (value) {\n      activeSpells.push(value);\n    }\n  });\n  return {\n    monsterSpellsMatrixOnBiome,\n    activeSpells\n  };\n}\n\nexport const excludeSpellsFomPrevShiftDirection = (spells, shiftSpell) => {\n  const opositeShiftDirection = getOpositeShiftDirection(shiftSpell);\n  const previousSpell = getSpellByShiftDirection(opositeShiftDirection);\n\n  if (previousSpell) {\n    return spells.filter(s => s !== previousSpell);\n  }\n\n  return spells;\n}\n\nexport const getOpositeShiftDirection = (shiftSpell) => {\n  switch (JSON.stringify(shiftSpell)) {\n    case '[-1,0]':\n      return [1,0];\n    case '[0,1]':\n      return [0,-1];\n    case '[1,0]':\n      return [-1,0];\n    case '[0,-1]':\n      return [0,1];\n    default:\n      return [0,0];\n  }\n}\n\nexport const getSpellByShiftDirection = (shiftSpell) => {\n  switch (JSON.stringify(shiftSpell)) {\n    case '[-1,0]':\n      return Y;\n    case '[0,1]':\n      return B;\n    case '[1,0]':\n      return G;\n    case '[0,-1]':\n      return R;\n    default:\n      return false;\n  }\n}\n\nexport const getShiftDirectionBySpell = (spell) => {\n  switch (spell) {\n    case Y:\n      return [-1, 0];\n    case B: \n      return [0, 1];\n    case G:\n      return [1, 0];\n    case R:\n      return [0, -1];\n    default:\n      return [0, 0];\n  }\n}\n\nexport const getSpellsNotReachedLimitInCurrentTest = (heroSpells, monsterSpellsOnBiome) => {\n  const result = [];\n  heroSpells.map(spell => {\n    const heroSpellCount = heroSpells.filter(v => v===spell).length;\n    const monsterSpellCount = monsterSpellsOnBiome.filter(v => v===spell).length;\n    if (heroSpellCount > monsterSpellCount && !result.includes(spell)) {\n      result.push(spell);\n    }\n    return result;\n  });\n  return result;\n}\n\nexport const getOptimalShiftSpellDirection = ({ prevFightResult, hero }) => {\n  const { monsterSpellsOnBiome, failureRecord, shiftSpell } = prevFightResult;\n  const nonFailedSpells = failureRecord.filter(x=> !x.diff).map(x=> x.spell);\n  const nonFailedSpellsExcludingPrevShift = shiftSpell ? excludeSpellsFomPrevShiftDirection(nonFailedSpells, shiftSpell) : nonFailedSpells;\n  const spellsNotReachedLimitInCurrentTest = getSpellsNotReachedLimitInCurrentTest(hero.spells, monsterSpellsOnBiome);\n  const validSpellsToUse = nonFailedSpellsExcludingPrevShift.filter(spell => spellsNotReachedLimitInCurrentTest.includes(spell));\n  const heroStrongestSpell = hero.getStrongestSpell();\n  const spellToUse = validSpellsToUse.includes(heroStrongestSpell) ? heroStrongestSpell : validSpellsToUse.pop();\n\n  return getShiftDirectionBySpell(spellToUse);\n}\n\nexport const getCurrentHeroStatus = hero => ({\n  shiftSpellScrollsLeft: hero.shiftSpellScrolls,\n  healPotionsLeft: hero.healPotions,\n  spells: hero.getSpells(),\n  strongestSpell: hero.getStrongestSpell(),\n  runesLeft: hero.runes,\n});\n\nexport const fightWithMonster = ({ hero, monster, biome, shiftSpell, runes }) => {\n  const { monsterSpellsMatrixOnBiome, activeSpells } = getMonsterSpellsOnBiome(biome.matrix, monster.matrix, shiftSpell);\n  const fightResult = compareSpellsCounts(hero.spells, activeSpells, runes);\n  return {\n    ...fightResult,\n    monsterSpellsMatrixOnBiome,\n    shiftSpell,\n    runes,\n    heroStatus: getCurrentHeroStatus(hero),\n  }\n}\n\nexport const getFailedSpellsCount = fightResult => {\n  return getFailedSpells(fightResult).reduce((acc, fail) => {\n    return acc + fail.diff;\n  }, 0);\n}\n\nexport const getFailedSpells = (fightResult = {}) => {\n  const { failureRecord = [{}] } = fightResult;\n  return failureRecord.filter(x=> x.diff);\n};\n\nexport const fightWithMonsterUsingRunes = ({ hero, monster, biome, prevFightResult }) => {\n  const failedSpells = getFailedSpells(prevFightResult);\n  const failedSpellsTotalCount = getFailedSpellsCount(prevFightResult);\n  if (hero.runes >= failedSpellsTotalCount) {\n    hero.useRunes(failedSpellsTotalCount);\n    let fightResult = fightWithMonster({ hero, monster, biome, runes: failedSpells });\n    return {...fightResult, runesWasUsed: true };\n  }\n\n  return prevFightResult;\n}\n\nexport const fightWithMonsterUsingSpells = ({ hero, monster, biome, shiftSpell, isTestCheck }) => {\n  if (!isTestCheck) {\n    hero.useShiftSpellScroll();\n  }\n  let fightResult = fightWithMonster({ hero, monster, biome, shiftSpell });\n  return {...fightResult, shiftSpellWasUsed: true };\n}\n\nexport const fightWithMonsterUsingSpellsChooseDirection = ({ hero, monster, biome, prevFightResult }) => {\n  const checkAllSpellShiftDirections = randomWeighted({0: .5, 1: .5});\n  if (checkAllSpellShiftDirections) {\n    return fightWithMonsterUsingSpellsTestAllDirections({ hero, monster, biome, prevFightResult })\n  } else {\n    return fightWithMonsterUsingSpellsTestOptimalDirection({ hero, monster, biome, prevFightResult });\n  }\n}\n\nexport const fightWithMonsterUsingSpellsTestAllDirections = ({ hero, monster, biome, prevFightResult }) => {\n  hero.useShiftSpellScroll();\n\n  let fightResult = fightWithMonsterUsingSpells({ hero, monster, biome, shiftSpell: [0,1], isTestCheck:true });\n\n  if (!fightResult.isSuccess) {\n    fightResult = fightWithMonsterUsingSpells({ hero, monster, biome, shiftSpell: [0,-1], isTestCheck:true });\n  }\n\n  if (!fightResult.isSuccess) {\n    fightResult = fightWithMonsterUsingSpells({ hero, monster, biome, shiftSpell: [1,0], isTestCheck:true });\n  }\n\n  if (!fightResult.isSuccess) {\n    fightResult = fightWithMonsterUsingSpells({ hero, monster, biome, shiftSpell: [-1,0], isTestCheck:true });\n  }\n\n  // If none of spell directions usage succeed, return the optimal direction's figthResult\n  // so the upcomind phases may use it as a starting point\n  if (!fightResult.isSuccess) {\n    fightResult = fightWithMonsterUsingSpellsTestOptimalDirection({ hero, monster, biome, prevFightResult, isTestCheck:true });\n  }\n\n  return fightResult;\n}\n\nexport const fightWithMonsterUsingSpellsTestOptimalDirection = ({ hero, monster, biome, prevFightResult, isTestCheck }) => {\n  hero.useShiftSpellScroll();\n  const optimalShiftSpellDirection = getOptimalShiftSpellDirection({ prevFightResult, hero });\n  return fightWithMonsterUsingSpells({ hero, monster, biome, shiftSpell:optimalShiftSpellDirection, isTestCheck });\n}\n\nexport const getMonsterWithShiftedMatrix = (monster, shiftSpell) => ({\n  ...monster,\n  matrix: shiftMatrix(monster.matrix, shiftSpell),\n});\n\nexport const getMonsterTrophiesCountOutsiderHero = (heroesArray) => {\n  let outsider = heroesArray[0];\n  heroesArray.forEach(hero => {\n    if (hero !== outsider && hero.getMonsterTrophiesCount() < outsider.getMonsterTrophiesCount()) {\n      outsider = hero;\n    }\n  });\n  return outsider;\n}\n\nexport const getMonsterTrophiesCountLeaderHero = (heroesArray) => {\n  let leader = heroesArray[heroesArray.length - 1];\n  heroesArray.forEach(hero => {\n    if (hero !== leader && hero.getMonsterTrophiesCount() > leader.getMonsterTrophiesCount()) {\n      leader = hero;\n    }\n  });\n  return leader;\n}\n\nexport const getMonsterTrophiesCountHeroesDiff = (leader, outsider) => {\n  return leader.getMonsterTrophiesCount() - outsider.getMonsterTrophiesCount();\n}\n\nexport const attackMonster = ({hero, monster, biome, turnRecord}) => {\n  let currentMonster = monster;\n  let fightResult = fightWithMonster({ hero, monster, biome });\n  turnRecord.phases.push(fightResult);\n\n  if (!fightResult.isSuccess && hero.shiftSpellScrolls) {\n    fightResult = fightWithMonsterUsingSpellsChooseDirection({ hero, monster: currentMonster, biome, prevFightResult: fightResult });\n    currentMonster = getMonsterWithShiftedMatrix(currentMonster, fightResult.shiftSpell);\n    turnRecord.phases.push(fightResult);\n    if (!fightResult.isSuccess && fightResult.shiftSpell && hero.shiftSpellScrolls &&!!randomWeighted({0: .4, 1: .6})) {\n      fightResult = fightWithMonsterUsingSpellsChooseDirection({ hero, monster: currentMonster, biome, prevFightResult: fightResult });\n      currentMonster = getMonsterWithShiftedMatrix(currentMonster, fightResult.shiftSpell);\n      turnRecord.phases.push(fightResult);\n    }\n  }\n\n  if (!fightResult.isSuccess && hero.runes >= getFailedSpellsCount(fightResult)) {\n    // console.log({hero});\n    fightResult = fightWithMonsterUsingRunes({ hero, monster: currentMonster, biome, prevFightResult: fightResult });\n    // console.log({fightResult});\n    turnRecord.phases.push(fightResult);\n  }\n\n  turnRecord.isSuccess = fightResult.isSuccess;\n  if (fightResult.isSuccess) {\n    hero.addMonsterTrophy(monster);\n  } else {\n    hero.hit();\n  }\n  return turnRecord;\n}\n\n\nexport const heroTurn = ({hero, biome}) => {\n  const turnRecord = {\n    key: Math.random(),\n    hero,\n    biome,\n    phases: [],\n  };\n\n  const possibleEncounters = [MONSTER, SHIFT_SCROLL, HEAL_POTION, RUNE];\n  const currentEncounter = possibleEncounters[randomWeighted({0: .6, 1: .2, 2: .1, 3: .1})];\n\n  if(currentEncounter === MONSTER) {\n    const monster = monstersArray[Math.floor(Math.random() * monstersArray.length)];\n    turnRecord.monster = monster;\n    attackMonster({hero, monster, biome, turnRecord});\n  } else if (currentEncounter === SHIFT_SCROLL) {\n    turnRecord.findShiftScroll = true;\n    hero.addShiftSpellScroll();\n  } else if (currentEncounter === HEAL_POTION) {\n    turnRecord.findHealPotion = true;\n    hero.addHealPotion();\n  } else if (currentEncounter === RUNE) {\n    turnRecord.findRune = true;\n    hero.addRune();\n  }\n\n  return {\n    ...turnRecord,\n    heroStatus: getCurrentHeroStatus(hero)\n  };\n}\n","import { Y, B, G, R,  SHIFT_SCROLL, HEAL_POTION, RUNE } from '../const';\nimport { randomInt } from '../utils';\n\nconst MAX_SPELLS = 5;\nconst MIN_SPELLS = 4;\nconst START_SHIFT_SPELL_SCROLLS = 1;\nconst START_HEAL_POTION = 1;\nconst START_RUNES = 1;\n\n\nexport default class Hero {\n  constructor(name, spells) {\n    this.name = name;\n    this.spells = spells.slice(0, MAX_SPELLS).sort();\n    this.shiftSpellScrolls = START_SHIFT_SPELL_SCROLLS;\n    this.healPotions = START_HEAL_POTION;\n    this.runes = START_RUNES;\n    this.monsterTrophies = [];\n  }\n\n  getSpells() {\n    return [...this.spells];\n  }\n\n  getStrongestSpell() {\n    return [...this.spells].sort((a,b) =>\n    this.spells.filter(v => v===a).length - this.spells.filter(v => v===b).length\n    )[this.spells.length - 1];\n  }\n\n  useShiftSpellScroll() {\n    this.shiftSpellScrolls && this.shiftSpellScrolls--;\n  }\n\n  addShiftSpellScroll(num = 1) {\n    const newScrolls = Number(num);\n    this.shiftSpellScrolls += newScrolls;\n  }\n\n  addHealPotion() {\n    if(this.spells.length < MAX_SPELLS) {\n      this.addRandomSpell();\n    } else {\n      this.healPotions++;\n    }\n  }\n\n  addRune() {\n    this.runes++;\n  }\n\n  useRunes(runesUsedCount) {\n    this.runes-=runesUsedCount;\n  }\n\n  hit() {\n    if(this.healPotions) {\n      this.useHealPotion();\n    } else if (this.spells.length > MIN_SPELLS) {\n      this.removeRandomSpell();\n    };\n  }\n\n  useHealPotion() {\n    this.healPotions && this.healPotions--;\n  }\n\n  removeRandomSpell() {\n    const spellIndex = this.spells[Math.floor(Math.random() * this.spells.length)];\n    this.spells.splice(spellIndex - 1, 1);\n  }\n\n  addRandomSpell() {\n    const possibleSpells = [Y, B, G, R];\n    // first try to add spell type missed in heroes spells list\n    const missedSpells = possibleSpells.filter(s => !this.spells.includes(s));\n    let spell;\n    if (missedSpells.length) {\n      spell = missedSpells.pop();\n    } else {\n      // otherwise add random spell\n      spell = possibleSpells[Math.floor(Math.random() * possibleSpells.length)];\n    }\n    this.spells.push(spell);\n  }\n\n  addMonsterTrophy(monster) {\n    this.monsterTrophies.push(monster);\n  }\n\n  getMonsterTrophiesCount() {\n    return this.monsterTrophies.length;\n  }\n\n  getMonsterTrophiesPoints() {\n    return this.monsterTrophies.reduce((acc, monster) => acc + monster.getStrength(), 0);\n  }\n\n  getTotalPoints() {\n    return this.getMonsterTrophiesPoints() + this.runes + this.healPotions + this.shiftSpellScrolls;\n  }\n\n  giveRandomTreasure() {\n    let treasureGift = [SHIFT_SCROLL, HEAL_POTION, RUNE][randomInt(3)];\n\n    if( this.spells.length < MAX_SPELLS) {\n      treasureGift = HEAL_POTION;\n    }\n\n    switch (treasureGift) {\n      case SHIFT_SCROLL:\n        this.addShiftSpellScroll();\n        break;\n      case HEAL_POTION:\n        this.addHealPotion();\n        break;\n      case RUNE:\n        this.addRune();\n        break;\n      default:\n        return;\n    }\n  }\n}","import { Y, B, G, R } from './const';\nimport Hero from './classes/hero';\n\nexport const hero1 = new Hero(\"Egemon\", [R,G,Y,B,Y]);\nexport const hero2 = new Hero(\"Alex\", [R,G,Y,B,B]);\nexport const hero3 = new Hero(\"Steve\", [R,G,Y,B,G]);\nexport const hero4 = new Hero(\"Amogus\", [R,G,Y,B,R]);\n\nexport const heroesArray = [hero1, hero2, hero3, hero4];\n\nexport const getNewHeroes = () => {\n  const hero1 = new Hero(\"Egemon\", [R,G,Y,B,Y]);\n  const hero2 = new Hero(\"Alex\", [R,G,Y,B,B]);\n  const hero3 = new Hero(\"Steve\", [R,G,Y,B,G]);\n  const hero4 = new Hero(\"Amogus\", [R,G,Y,B,R]);\n  return [hero1, hero2, hero3, hero4];\n}","import React from 'react';\n\nexport default function TurnHero({hero, heroStatus}) {\n  const heroStrongestSpell = heroStatus ? heroStatus.strongestSpell : hero.getStrongestSpell();\n  const shiftSpellScrollsLeft = heroStatus ? heroStatus.shiftSpellScrollsLeft : hero.shiftSpellScrolls;\n  const runesLeft = heroStatus ? heroStatus.runesLeft : hero.runes;\n  const healPotionsLeft = heroStatus ? heroStatus.healPotionsLeft : hero.healPotions;\n  const spells = heroStatus ? heroStatus.spells : hero.spells;\n\n  return (\n    <div className=\"hero\">\n      <h3>{hero.name}</h3>\n      <div>Shifts Scrolls: <b>{shiftSpellScrollsLeft}</b></div>\n      <div>Runes: <b>{runesLeft}</b></div>\n      <div>Heal potions: <b>{healPotionsLeft}</b></div>\n      <div className=\"spells\">\n        {spells.map((spell, index) => <span key={index} className={`spell spell-${spell}`}>{spell}</span>)}\n      </div>\n      <span className=\"spells\">\n        Strongest: <span className={`spell spell-${heroStrongestSpell}`}>{heroStrongestSpell}</span>\n     </span>\n     <div className=\"monsterTrophies\">Monsters trophies: <b>{hero.getMonsterTrophiesCount()}/{hero.getMonsterTrophiesPoints()}</b><br/>\n     Total points: <b>{hero.getTotalPoints()}</b></div>\n    </div>\n  );\n};\n","import React from 'react';\n// import * as math from 'mathjs';\n\nexport default function BiomeMatrix({biome}) {\n  const biomeArr = biome.matrix.valueOf();\n\n  return (\n    <div className=\"biome-matrix\">\n      <div className=\"spells-matrix\">\n        {biomeArr.map((spellsRow, index) => <div key={index} className=\"spells\">{spellsRow.map((spell, index) => <span key={index} className={`spell spell-${spell}`}>{spell}</span>)}</div>)}\n      </div>\n    </div>\n  );\n};\n","import React from 'react';\n// import * as math from 'mathjs';\n\nexport default function MonsterMatrix({monsterSpellsMatrixOnBiome}) {\n  const monsterArr = monsterSpellsMatrixOnBiome.valueOf();\n\n  return (\n    <div className=\"monster-matrix\">\n      <div className=\"spells-matrix\">\n        {monsterArr.map((spellsRow, index) => <div key={index} className=\"spells\">{spellsRow.map((spell, index) => <span key={index} className={`spell spell-${spell}`}>{spell}</span>)}</div>)}\n      </div>\n    </div>\n  );\n};\n","import React from 'react';\n\nexport default function TurnPhaseFailureRecord({failureRecord}) {  \n  return (\n    <div className=\"failureRecord\">\n      <span className=\"label\">Failure diff:</span>\n      <div className=\"spells\">\n        {failureRecord.map(({spell, diff}) => <span key={spell} className={`spell spell-${spell} ${!diff && 'empty'}`}>{diff ? diff : ' '}</span>)}\n      </div>\n    </div>\n  );\n};\n","import React from 'react';\nimport { Y, B, G, R } from '../const';\n\nexport default function TurnPhaseShiftSpellUsed({shiftSpell}) {\n\n  function getCurrentShiftSpellFromArray(shiftSpell) {\n    switch (JSON.stringify(shiftSpell)) {\n      case '[-1,0]':\n        return Y;\n      case '[0,1]': \n        return B;\n      case '[1,0]':\n        return G;\n      case '[0,-1]':\n        return R;\n      default:\n        return false; \n    }\n  }\n\n  const spell = getCurrentShiftSpellFromArray(shiftSpell);\n\n  return (\n    <div className=\"shiftSpellUsed\">\n      <span className=\"label\">Shift scroll:</span>\n      <div className=\"spells\">\n        <span className={`spell spell-${spell}`}></span>\n      </div>\n    </div>\n  );\n};\n","import React from 'react';\n// import { Y, B, G, R } from '../const';\n\nexport default function TurnPhaseRuneUsed({runes}) {\n\n  // function getCurrentShiftSpellFromArray(runes) {\n  //   switch (JSON.stringify(shiftSpell)) {\n  //     case '[-1,0]':\n  //       return Y;\n  //     case '[0,1]': \n  //       return B;\n  //     case '[1,0]':\n  //       return G;\n  //     case '[0,-1]':\n  //       return R;\n  //     default:\n  //       return false; \n  //   }\n  // }\n\n  // const spell = getCurrentShiftSpellFromArray(runes);\n\n  return (\n    <div className=\"runeUsed\">\n      <span className=\"label\">Rune:</span>\n      <div className=\"spells\">\n        {runes.map(({spell}) =><span key={spell} className={`spell spell-${spell}`}></span> )}\n      </div>\n    </div>\n  );\n};\n","import React from 'react';\nimport TurnHero from './turn-hero';\nimport './turn.css';\nimport BiomeMatrix from './biome-matrix';\nimport MonsterMatrix from './monster-matrix';\nimport TurnPhaseFailureRecord from './turnPhaseFailureRecord';\nimport TurnPhaseShiftSpellUsed from './turnPhaseShiftSpellUsed';\nimport TurnPhaseRuneUsed from './turnPhaseRuneUsed';\n\nexport default function Turn({turnRecord}) {\n  // console.log(turnRecord);\n  if (!turnRecord.monster) {\n    return <div className={`turn ${turnRecord.biome.name}`}>\n      <div className=\"treasure\">\n        {turnRecord.findShiftScroll && <span className=\"shiftSpell\">Shift spell scroll <br/><b>{turnRecord.heroStatus.shiftSpellScrollsLeft}</b></span>}\n        {turnRecord.findHealPotion && <span className=\"healPotion\">Heal potion<br/><b>{turnRecord.heroStatus.healPotionsLeft}</b></span>}\n        {turnRecord.findRune && <span className=\"rune\">Rune<br/><b>{turnRecord.heroStatus.runesLeft}</b></span>}\n      </div>\n    </div>\n  }\n  return (\n    <div className={`turn ${turnRecord.isSuccess ? 'isSuccess' : 'isFailure'} ${turnRecord.biome.name}`}>\n      <div className=\"turnDescription\">\n        <TurnHero hero={turnRecord.hero} heroStatus={turnRecord.phases[0].heroStatus} />\n        vs\n        <span className=\"meetDetails\"><b>{turnRecord.monster.name}</b> on the <b>{turnRecord.biome.name}</b> biome</span>\n      </div>\n      <div className=\"turnContent\">\n        {turnRecord.phases.map((phase, index) => <div className=\"turnPhase\" key={index}>\n            <div className=\"monsterAndBiomeMatrixes\">\n              <BiomeMatrix biome={turnRecord.biome}/>\n              <MonsterMatrix monsterSpellsMatrixOnBiome={phase.monsterSpellsMatrixOnBiome}/>\n            </div>\n            {phase.shiftSpellWasUsed && <TurnPhaseShiftSpellUsed shiftSpell={phase.shiftSpell}/>}\n            {phase.runesWasUsed && <TurnPhaseRuneUsed runes={phase.runes}/>}\n            {phase.failureRecord && <TurnPhaseFailureRecord className=\"failureRecord\" failureRecord={phase.failureRecord}/>}\n        </div>)}\n      </div>\n    </div>\n  );\n};\n","import { biomesArray } from './biomes';\nimport { getNewHeroes } from './heroes';\nimport { monstersArray } from './monsters';\n\nimport { fightWithMonster, getMonsterWithShiftedMatrix, getCurrentHeroStatus, fightWithMonsterUsingSpellsTestAllDirections } from './utils';\n\nimport Turn from './components/turn';\n\nconst heroesArray = getNewHeroes();\nconst turnRecords = window.turnRecordsMonstersOnBiomes = [];\nconsole.log({heroesArray});\n\nexport const attackMonster = ({hero, monster, biome, turnRecord}) => {\n  let currentMonster = monster;\n  let fightResult = fightWithMonster({ hero, monster, biome });\n  turnRecord.phases.push(fightResult);\n\n  if (!fightResult.isSuccess && hero.shiftSpellScrolls) {\n    fightResult = fightWithMonsterUsingSpellsTestAllDirections({ hero, monster: currentMonster, biome, prevFightResult: fightResult });\n    currentMonster = getMonsterWithShiftedMatrix(currentMonster, fightResult.shiftSpell);\n    turnRecord.phases.push(fightResult);\n    if (!fightResult.isSuccess && fightResult.shiftSpell && hero.shiftSpellScrolls) {\n      fightResult = fightWithMonsterUsingSpellsTestAllDirections({ hero, monster: currentMonster, biome, prevFightResult: fightResult });\n    }\n  }\n\n  turnRecord.isSuccess = fightResult.isSuccess;\n  return turnRecord;\n}\n\nexport const heroTurn = ({hero, biome, monster}) => {\n  const turnRecord = {\n    key: Math.random(),\n    hero,\n    biome,\n    monster,\n    phases: [],\n  };\n  return {\n    ...attackMonster({hero, monster, biome, turnRecord}),\n    heroStatus: getCurrentHeroStatus(hero)\n  };\n}\n\nmonstersArray.forEach((monster) => {\n  biomesArray.forEach((biome) => {\n    heroesArray.forEach((hero) => {\n      hero.addShiftSpellScroll(100)\n      turnRecords.push( \n        heroTurn({ hero, monster, biome })\n      )\n    })\n  })\n})\n\nconst turnRecordsByMonsters = turnRecords.reduce((acc, turn) => {\n  const { biome: { name: biomeName }, monster: { name: monsterName } } = turn;\n  if (!acc[monsterName]) {\n    acc[monsterName] = {};\n  }\n  if (!acc[monsterName][biomeName]) {\n    acc[monsterName][biomeName] = []\n  }\n  acc[monsterName][biomeName].push(turn);\n  return acc;\n}, {});\n\nexport default function MonstersOnBiomes() {\n  return (\n    <div className=\"monstersRecords\">\n      {Object.entries(turnRecordsByMonsters).map(([monsterName, biomes]) => <div className=\"monsterRecords\" key={monsterName}>\n        <h3>{monsterName}</h3>\n        {Object.entries(biomes).map(([biomeName, heroes]) => {\n          return <div className=\"biomeRecords\" key={biomeName + monsterName}>\n            <h4>{biomeName}: {heroes.length}</h4>\n            {heroes.map(turnRecord => <Turn key={turnRecord.key + biomeName + monsterName} turnRecord={turnRecord} />)}\n          </div>\n        })} \n      </div>)}\n    </div>\n  );\n}","import { biomesArray } from './biomes';\nimport { heroesArray } from './heroes';\n\nimport { randomInt, randomWeighted, getMonsterTrophiesCountOutsiderHero, getMonsterTrophiesCountLeaderHero, getMonsterTrophiesCountHeroesDiff, heroTurn } from './utils';\n\n\nimport Turn from './components/turn';\nimport TurnHero from './components/turn-hero';\n\nconst turnRecords = window.turnRecords = [];\nconst roundsCount = 10;\n\nfor (let index = 0; index < roundsCount; index++) {\n  const outsiderHero = getMonsterTrophiesCountOutsiderHero(heroesArray);\n  const leaderHero = getMonsterTrophiesCountLeaderHero(heroesArray);\n  if(getMonsterTrophiesCountHeroesDiff(leaderHero, outsiderHero) >= 2) {\n    outsiderHero.giveRandomTreasure();\n  }\n\n  heroesArray.forEach((hero) => {\n    const prefferableBiomeType = hero.getStrongestSpell();\n    const prefferableBiome = biomesArray.find(b => b.type === prefferableBiomeType);\n    const randomBiome = biomesArray[randomInt(biomesArray.length)];\n    let currentBiome = [prefferableBiome, randomBiome][randomWeighted({0: .8, 1: .2})];\n    // if(!(index && index % 4)) { // every 4-th iteration add a tile to the biome\n    //   heroTurn({hero, biome: currentBiome});\n    // }\n\n    if(hero === outsiderHero) {\n      currentBiome = randomBiome;\n      turnRecords.push([\n        heroTurn({hero, biome: currentBiome}),\n        heroTurn({hero, biome: currentBiome})\n      ]);\n    } else {\n      turnRecords.push(heroTurn({hero, biome: currentBiome}))\n    }\n  })\n}\n\n  // console.log('-', {\n  //   wins: fightResultsArray.filter(x => x).length,\n  //   fails: fightResultsArray.filter(x => !x).length,\n  //   shiftSpellUseCount,\n  //   fightResultsArray,\n  //   spellComparisonFailuresArray,\n  // });\n\nconst turnRecordsByHero = turnRecords.reduce((acc, turn) => {\n  const { name } = turn.hero || turn[0].hero;\n  if (!acc[name]) {\n    acc[name] = [];\n  }\n  acc[name].push(turn);\n  return acc;\n}, {});\n\nconsole.log({turnRecordsByHero});\n\nexport default function CompetitiveMode() {\n  return (\n    <div>\n      <div className=\"heroesRecords final\">\n        {Object.entries(turnRecordsByHero).map(([key, value]) => <div className=\"heroRecords\" key={key}>\n          <TurnHero hero={value[0].hero || value[0][0].hero} />\n        </div>)}\n      </div>\n        <hr />\n      {/* {turnRecords.map(turnRecord => <Turn key={turnRecord.key} turnRecord={turnRecord} />)} */}\n      <div className=\"heroesRecords\">\n        {Object.entries(turnRecordsByHero).map(([key, value]) => <div className=\"heroRecords\" key={key}>\n          <h3>{key}</h3>\n          {value.map((turnRecord, index ) => {\n            return Array.isArray(turnRecord)\n              ? <div className=\"doubleTurn\" key={index}>\n                  {turnRecord.map(turnRecordInner => {\n                    return <Turn key={turnRecordInner.key} turnRecord={turnRecordInner} />\n                  })}\n                </div>\n              : <Turn key={turnRecord.key} turnRecord={turnRecord} />\n          })}\n        </div>)}\n      </div>\n    </div>\n  );\n}","import  React, { useState }  from 'react';\nimport MonstersOnBiomes from './monsters-on-biomes';\nimport CompetitiveMode from './competitive-mode';\n\n\nfunction App() {\n  const [showMonstersOnBiomes, setShowMonstersOnBiomes] = useState(false);\n  return (\n    <div className=\"App\">\n      <h2>The Spells shifters game</h2>\n      <CompetitiveMode/>\n      <br /><br /><br /><br />\n      <hr/>\n      <label>\n        <input type=\"checkbox\" checked={showMonstersOnBiomes} onChange={() => setShowMonstersOnBiomes(!showMonstersOnBiomes)} />\n        Show monsters statistic (wait to render)\n      </label>\n      {showMonstersOnBiomes && <>\n        <h1>Monsters statistic</h1>\n        <MonstersOnBiomes/>\n      </>}\n      <br /><br /><br /><br /><br /><br /><br /><br />\n    </div>\n  );\n}\nconsole.log('-------');\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}
{"version":3,"sources":["const.js","classes/monster.js","monsters.js","classes/biome.js","biomes.js","utils.js","classes/hero.js","heroes.js","components/turn-hero.js","components/biome-matrix.js","components/monster-matrix.js","components/turnPhaseFailureRecord.js","components/turnPhaseShiftSpellUsed.js","components/turnPhaseRuneUsed.js","components/turn.js","App.js","index.js"],"names":["SHIFT_SCROLL","HEAL_POTION","RUNE","MONSTER","Monster","name","matrix","this","strength","forEach","value","monstersArray","math","Biome","type","biomesArray","randomWeighted","prob","i","sum","r","Math","random","Number","randomInt","int","floor","getSpellTypeCount","spells","spellType","filter","x","length","getSpellsCountsDiffByType","heroSpells","monsterSpells","runesCount","saveSpellsComparisonFailureRecord","monsterSpellsOnBiome","getSpellsCountsDiffByTypeY","getSpellsCountsDiffByTypeB","getSpellsCountsDiffByTypeG","getSpellsCountsDiffByTypeR","spell","diff","abs","checkSpellsComparisonSuccessByType","runes","runesByType","find","runesByTypeCount","shiftMatrix","shift","result","shiftFailed","index","y","valueOf","subset","getOpositeShiftDirection","shiftSpell","JSON","stringify","getSpellByShiftDirection","getOptimalShiftSpellDirection","prevFightResult","hero","failureRecord","nonFailedSpells","map","nonFailedSpellsExcludingPrevShift","opositeShiftDirection","previousSpell","s","excludeSpellsFomPrevShiftDirection","spellsNotReachedLimitInCurrentTest","v","includes","push","getSpellsNotReachedLimitInCurrentTest","validSpellsToUse","heroStrongestSpell","getStrongestSpell","getShiftDirectionBySpell","pop","getCurrenHeroStatus","shiftSpellScrollsLeft","shiftSpellScrolls","healPotionsLeft","healPotions","getSpells","strongestSpell","runesLeft","fightWithMonster","monster","biome","biomeMatrix","mask","monsterSpellsMatrixOnBiome","get","applyMask","activeSpells","getMonsterSpellsOnBiome","fightResult","compareSpellsCountsByTypeY","compareSpellsCountsByTypeB","compareSpellsCountsByTypeG","compareSpellsCountsByTypeR","isComparisonSuccess","isSuccess","sort","usedRunes","compareSpellsCounts","heroStatus","getFailedSpellsCount","getFailedSpells","reduce","acc","fail","fightWithMonsterUsingSpells","shiftSpellWasUsed","fightWithMonsterUsingSpellsTestAllDirections","fightResultUsingSpellsInOptimalDirection","fightWithMonsterUsingSpellsTestOptimalDirection","useShiftSpellScroll","optimalShiftSpellDirection","getMonsterWithShiftedMatrix","Hero","slice","monsterTrophies","a","b","addRandomSpell","runesUsedCount","useHealPotion","removeRandomSpell","spellIndex","splice","possibleSpells","missedSpells","getStrength","getMonsterTrophiesPoints","treasureGift","addShiftSpellScroll","addHealPotion","addRune","heroesArray","TurnHero","className","getMonsterTrophiesCount","getTotalPoints","BiomeMatrix","biomeArr","spellsRow","MonsterMatrix","monsterArr","TurnPhaseFailureRecord","TurnPhaseShiftSpellUsed","getCurrentShiftSpellFromArray","TurnPhaseRuneUsed","Turn","turnRecord","phases","phase","runesWasUsed","findShiftScroll","findHealPotion","findRune","turnRecords","window","attackMonster","currentMonster","failedSpells","failedSpellsTotalCount","useRunes","fightWithMonsterUsingRunes","addMonsterTrophy","hit","heroTurn","key","currentEncounter","outsider","outsiderHero","getMonsterTrophiesCountOutsiderHero","leaderHero","leader","getMonsterTrophiesCountLeaderHero","prefferableBiomeType","prefferableBiome","randomBiome","currentBiome","turnRecordsByHero","turn","console","log","App","Object","entries","Array","isArray","turnRecordInner","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.71b551da.chunk.js","sourcesContent":["export const Y = 1;\nexport const B = 2;\nexport const G = 3;\nexport const R = 4;\n\nexport const SHIFT_SCROLL = 'shift scroll';\nexport const HEAL_POTION = 'heal potion';\nexport const RUNE = 'rune';\nexport const MONSTER = 'monster';","export default class Monster {\n  constructor(name, matrix) {\n    this.name = name;\n    this.matrix = matrix;\n  }\n\n  getStrength() {\n    let strength = 0;\n    this.matrix.forEach(value => {\n      if (value) {\n        strength++;\n      }\n    });\n    return strength;\n  }\n}","import * as math from 'mathjs';\n\nimport Monster from './classes/monster';\n\nexport const monster1 = new Monster(\"Flower bird\", math.matrix([\n  [0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0],\n  [0,0,1,1,1,0,0],\n  [0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0],\n]));\n\nexport const monster2 = new Monster(\"Fire ball\", math.matrix([\n  [0,0,0,0,0,0,0],\n  [0,0,1,0,0,0,0],\n  [0,0,1,0,0,0,0],\n  [0,0,1,0,0,0,0],\n  [0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0],\n]));\n\nexport const monster3 = new Monster(\"Ktulhu guard\", math.matrix([\n  [0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0],\n  [0,0,0,1,1,1,0],\n  [0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0],\n]));\n\nexport const monster4 = new Monster(\"Fat imp\", math.matrix([\n  [0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0],\n  [0,0,0,1,1,0,0],\n  [0,0,0,1,1,0,0],\n  [0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0],\n]));\n\nexport const monster5 = new Monster(\"Big foot\", math.matrix([\n  [0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0],\n  [0,1,1,1,0,0,0],\n  [0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0],\n]));\n\nexport const monster6 = new Monster(\"Furry\", math.matrix([\n  [0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0],\n  [0,0,1,1,0,0,0],\n  [0,0,1,1,0,0,0],\n  [0,0,0,0,0,0,0],\n  [0,0,0,0,0,0,0],\n]));\n\n\nexport const monstersArray = [monster1, monster2, monster3, monster4, monster5, monster6];\n","export default class Biome {\n  constructor(name, type, matrix) {\n    this.name = name;\n    this.matrix = matrix;\n    this.type = type;\n  }\n}","import * as math from 'mathjs';\nimport { Y, B, G, R } from './const';\nimport Biome from './classes/biome';\n\nexport const biome1 = new Biome(\"Desert\", Y, math.matrix([\n  [R,Y,Y,Y,Y,Y,Y],\n  [R,Y,Y,Y,Y,Y,Y],\n  [R,R,Y,Y,Y,B,B],\n  [R,R,R,Y,B,B,B],\n  [R,R,R,G,B,B,B],\n  [R,R,G,G,G,B,B],\n  [G,G,G,G,G,G,B],\n]));\n\nexport const biome2 = new Biome(\"River\", B, math.matrix([\n  [Y,Y,Y,Y,Y,Y,Y],\n  [R,Y,Y,Y,Y,B,B],\n  [R,Y,Y,Y,B,B,B],\n  [R,R,R,B,B,B,B],\n  [R,R,G,G,B,B,B],\n  [R,G,G,G,B,B,B],\n  [G,G,G,G,G,G,B],\n]));\n\nexport const biome3 = new Biome(\"Forest\", G, math.matrix([\n  [Y,Y,Y,Y,Y,Y,Y],\n  [R,Y,Y,Y,Y,B,B],\n  [R,R,R,Y,B,B,B],\n  [R,R,R,G,B,B,B],\n  [R,G,G,G,B,B,B],\n  [G,G,G,G,G,G,B],\n  [G,G,G,G,G,G,B],\n]));\n\nexport const biome4 = new Biome(\"Fire land\", R, math.matrix([\n  [R,Y,Y,Y,Y,Y,Y],\n  [R,R,Y,Y,Y,Y,B],\n  [R,R,R,Y,Y,B,B],\n  [R,R,R,R,B,B,B],\n  [R,R,R,G,G,B,B],\n  [R,R,R,G,G,B,B],\n  [G,G,G,G,G,G,B],\n]));\n\nexport const biomesArray = [biome1, biome2, biome3, biome4];\n","import * as math from 'mathjs';\nimport { Y, B, G, R } from './const';\n\nexport const randomWeighted = prob => {\n  let i, sum=0, r=Math.random();\n  for (i in prob) {\n    sum += prob[i];\n    if (r <= sum) return Number(i);\n  }\n}\n\nexport const randomInt = int => Math.floor(Math.random()) * int;\n\nexport const getSpellTypeCount = (spells, spellType) => spells.filter(x=> x === spellType).length;\n\nexport const getSpellsCountsDiffByType = (heroSpells, monsterSpells, spellType, runesCount = 0) => getSpellTypeCount(heroSpells, spellType) - getSpellTypeCount(monsterSpells, spellType) + runesCount;\n\nexport const saveSpellsComparisonFailureRecord = (heroSpells, monsterSpellsOnBiome) => {\n  const getSpellsCountsDiffByTypeY = getSpellsCountsDiffByType(heroSpells, monsterSpellsOnBiome, Y);\n  const getSpellsCountsDiffByTypeB = getSpellsCountsDiffByType(heroSpells, monsterSpellsOnBiome, B);\n  const getSpellsCountsDiffByTypeG = getSpellsCountsDiffByType(heroSpells, monsterSpellsOnBiome, G);\n  const getSpellsCountsDiffByTypeR = getSpellsCountsDiffByType(heroSpells, monsterSpellsOnBiome, R);\n\n  const spellComparisonFailureRecord = [\n    {spell: Y, diff: getSpellsCountsDiffByTypeY < 0 ? Math.abs(getSpellsCountsDiffByTypeY) : 0},\n    {spell: B, diff: getSpellsCountsDiffByTypeB < 0 ? Math.abs(getSpellsCountsDiffByTypeB) : 0},\n    {spell: G, diff: getSpellsCountsDiffByTypeG < 0 ? Math.abs(getSpellsCountsDiffByTypeG) : 0},\n    {spell: R, diff: getSpellsCountsDiffByTypeR < 0 ? Math.abs(getSpellsCountsDiffByTypeR) : 0},\n  ];\n\n  // spellComparisonFailuresArray.push(spellComparisonFailureRecord);\n  return spellComparisonFailureRecord;\n}\n\nexport const checkSpellsComparisonSuccessByType = (heroSpells, monsterSpells, spellType, runes = []) => {\n  const runesByType = runes.find(x=>x.spell === spellType) || {};\n  const runesByTypeCount = runesByType.diff || 0;\n  return getSpellsCountsDiffByType(heroSpells, monsterSpells, spellType, runesByTypeCount) >= 0;\n}\n\n// matrix - math.js matrix, shift - array with shift direction [1,0], [0, -1], ... etc.\nexport const shiftMatrix = (matrix, shift) => {\n  let result = math.zeros(math.size(matrix));\n  let shiftFailed = false;\n\n  matrix.forEach((value, index) => {\n    if (value) {\n      const y = index[0] + shift[0];\n      const x = index[1] + shift[1];\n\n      if (y < 0 || y >= math.size(result).valueOf()[0]) {\n        shiftFailed = true;\n        return false;\n      }\n\n      if (x < 0 || x >= math.size(result).valueOf()[1]) {\n        shiftFailed = true;\n        return false;\n      }\n      result.subset(math.index(y,x),1);\n    }\n  });\n\n  if (shiftFailed) {\n    result = matrix;\n  }\n\n  return result;\n};\n\nexport const applyMask = (biome, mask) => biome.map((value, index) => value * mask.get(index));\n\nexport const compareSpellsCounts = (heroSpells, monsterSpellsOnBiome, runes) => {\n  // let unusedRunes = [...runes];\n  const compareSpellsCountsByTypeY = checkSpellsComparisonSuccessByType(heroSpells, monsterSpellsOnBiome, Y, runes);\n  const compareSpellsCountsByTypeB = checkSpellsComparisonSuccessByType(heroSpells, monsterSpellsOnBiome, B, runes);\n  const compareSpellsCountsByTypeG = checkSpellsComparisonSuccessByType(heroSpells, monsterSpellsOnBiome, G, runes);\n  const compareSpellsCountsByTypeR = checkSpellsComparisonSuccessByType(heroSpells, monsterSpellsOnBiome, R, runes);\n\n  const isComparisonSuccess = compareSpellsCountsByTypeY\n                              && compareSpellsCountsByTypeB\n                              && compareSpellsCountsByTypeG\n                              && compareSpellsCountsByTypeR;\n\n  return {\n    isSuccess: isComparisonSuccess,\n    failureRecord: !isComparisonSuccess && saveSpellsComparisonFailureRecord(heroSpells, monsterSpellsOnBiome),\n    monsterSpellsOnBiome: monsterSpellsOnBiome.sort(),\n    usedRunes: runes\n  };  \n}\n\nexport const getMonsterSpellsOnBiome = (biomeMatrix, mask, shift) => {\n  if (shift) {\n    mask = shiftMatrix(mask, shift);\n  }\n  const monsterSpellsMatrixOnBiome = applyMask(biomeMatrix, mask);\n  const activeSpells = [];\n  monsterSpellsMatrixOnBiome.forEach(value => {\n    if (value) {\n      activeSpells.push(value);\n    }\n  });\n  return {\n    monsterSpellsMatrixOnBiome,\n    activeSpells\n  };\n}\n\nexport const excludeSpellsFomPrevShiftDirection = (spells, shiftSpell) => {\n  const opositeShiftDirection = getOpositeShiftDirection(shiftSpell);\n  const previousSpell = getSpellByShiftDirection(opositeShiftDirection);\n\n  if (previousSpell) {\n    return spells.filter(s => s !== previousSpell);\n  }\n\n  return spells;\n}\n\nexport const getOpositeShiftDirection = (shiftSpell) => {\n  switch (JSON.stringify(shiftSpell)) {\n    case '[-1,0]':\n      return [1,0];\n    case '[0,1]':\n      return [0,-1];\n    case '[1,0]':\n      return [-1,0];\n    case '[0,-1]':\n      return [0,1];\n    default:\n      return [0,0];\n  }\n}\n\nexport const getSpellByShiftDirection = (shiftSpell) => {\n  switch (JSON.stringify(shiftSpell)) {\n    case '[-1,0]':\n      return Y;\n    case '[0,1]':\n      return B;\n    case '[1,0]':\n      return G;\n    case '[0,-1]':\n      return R;\n    default:\n      return false;\n  }\n}\n\nexport const getShiftDirectionBySpell = (spell) => {\n  switch (spell) {\n    case Y:\n      return [-1, 0];\n    case B: \n      return [0, 1];\n    case G:\n      return [1, 0];\n    case R:\n      return [0, -1];\n    default:\n      return [0, 0];\n  }\n}\n\nexport const getSpellsNotReachedLimitInCurrentTest = (heroSpells, monsterSpellsOnBiome) => {\n  const result = [];\n  heroSpells.map(spell => {\n    const heroSpellCount = heroSpells.filter(v => v===spell).length;\n    const monsterSpellCount = monsterSpellsOnBiome.filter(v => v===spell).length;\n    if (heroSpellCount > monsterSpellCount && !result.includes(spell)) {\n      result.push(spell);\n    }\n  });\n  return result;\n}\n\nexport const getOptimalShiftSpellDirection = ({ prevFightResult, hero }) => {\n  const { monsterSpellsOnBiome, failureRecord, shiftSpell } = prevFightResult;\n  const nonFailedSpells = failureRecord.filter(x=> !x.diff).map(x=> x.spell);\n  const nonFailedSpellsExcludingPrevShift = shiftSpell ? excludeSpellsFomPrevShiftDirection(nonFailedSpells, shiftSpell) : nonFailedSpells;\n  const spellsNotReachedLimitInCurrentTest = getSpellsNotReachedLimitInCurrentTest(hero.spells, monsterSpellsOnBiome);\n  const validSpellsToUse = nonFailedSpellsExcludingPrevShift.filter(spell => spellsNotReachedLimitInCurrentTest.includes(spell));\n  const heroStrongestSpell = hero.getStrongestSpell();\n  const spellToUse = validSpellsToUse.includes(heroStrongestSpell) ? heroStrongestSpell : validSpellsToUse.pop();\n\n  return getShiftDirectionBySpell(spellToUse);\n}\n\nexport const getCurrenHeroStatus = hero => ({\n  shiftSpellScrollsLeft: hero.shiftSpellScrolls,\n  healPotionsLeft: hero.healPotions,\n  spells: hero.getSpells(),\n  strongestSpell: hero.getStrongestSpell(),\n  runesLeft: hero.runes,\n});\n\nexport const fightWithMonster = ({ hero, monster, biome, shiftSpell, runes }) => {\n  const { monsterSpellsMatrixOnBiome, activeSpells } = getMonsterSpellsOnBiome(biome.matrix, monster.matrix, shiftSpell);\n  const fightResult = compareSpellsCounts(hero.spells, activeSpells, runes);\n  return {\n    ...fightResult,\n    monsterSpellsMatrixOnBiome,\n    shiftSpell,\n    runes,\n    heroStatus: getCurrenHeroStatus(hero),\n  }\n}\n\nexport const getFailedSpellsCount = fightResult => {\n  return getFailedSpells(fightResult).reduce((acc, fail) => {\n    return acc + fail.diff;\n  }, 0);\n}\n\nexport const getFailedSpells = (fightResult = {}) => {\n  const { failureRecord = [{}] } = fightResult;\n  return failureRecord.filter(x=> x.diff);\n};\n\nexport const fightWithMonsterUsingRunes = ({ hero, monster, biome, prevFightResult }) => {\n  const failedSpells = getFailedSpells(prevFightResult);\n  const failedSpellsTotalCount = getFailedSpellsCount(prevFightResult);\n  if (hero.runes >= failedSpellsTotalCount) {\n    hero.useRunes(failedSpellsTotalCount);\n    let fightResult = fightWithMonster({ hero, monster, biome, runes: failedSpells });\n    return {...fightResult, runesWasUsed: true };\n  }\n\n  return prevFightResult;\n}\n\nexport const fightWithMonsterUsingSpells = ({ hero, monster, biome, shiftSpell }) => {\n  let fightResult = fightWithMonster({ hero, monster, biome, shiftSpell });\n  return {...fightResult, shiftSpellWasUsed: true };\n}\n\nexport const fightWithMonsterUsingSpellsTestAllDirections = ({ hero, monster, biome, prevFightResult }) => {\n  let fightResultUsingSpellsInOptimalDirection = fightWithMonsterUsingSpellsTestOptimalDirection({ hero, monster, biome, prevFightResult });\n  let fightResult = fightResultUsingSpellsInOptimalDirection;\n  hero.useShiftSpellScroll();\n\n  const checkAllSpellShiftDirections = randomWeighted({0: .5, 1: .5});\n\n  if (checkAllSpellShiftDirections) {\n    fightResult = fightWithMonsterUsingSpells({ hero, monster, biome, shiftSpell: [0,1] });\n\n    if (!fightResult.isSuccess) {\n      fightResult = fightWithMonsterUsingSpells({ hero, monster, biome, shiftSpell: [0,-1] });\n    }\n\n    if (!fightResult.isSuccess) {\n      fightResult = fightWithMonsterUsingSpells({ hero, monster, biome, shiftSpell: [1,0] });\n    }\n\n    if (!fightResult.isSuccess) {\n      fightResult = fightWithMonsterUsingSpells({ hero, monster, biome, shiftSpell: [-1,0] });\n    }\n\n    // If none of spell directions usage succeed, return the optimal direction's figthResult\n    if (!fightResult.isSuccess) {\n      fightResult = fightResultUsingSpellsInOptimalDirection;\n    }\n  }\n\n  return fightResult;\n}\n\nexport const fightWithMonsterUsingSpellsTestOptimalDirection = ({ hero, monster, biome, prevFightResult }) => {\n  const optimalShiftSpellDirection = getOptimalShiftSpellDirection({ prevFightResult, hero });\n  return fightWithMonsterUsingSpells({ hero, monster, biome, shiftSpell:optimalShiftSpellDirection });\n}\n\nexport const getMonsterWithShiftedMatrix = (monster, shiftSpell) => ({\n  ...monster,\n  matrix: shiftMatrix(monster.matrix, shiftSpell),\n});\n\nexport const getMonsterTrophiesCountOutsiderHero = (heroesArray) => {\n  let outsider = heroesArray[0];\n  heroesArray.forEach(hero => {\n    if (hero !== outsider && hero.getMonsterTrophiesCount() < outsider.getMonsterTrophiesCount()) {\n      outsider = hero;\n    }\n  });\n  return outsider;\n}\n\nexport const getMonsterTrophiesCountLeaderHero = (heroesArray) => {\n  let leader = heroesArray[heroesArray.length - 1];\n  heroesArray.forEach(hero => {\n    if (hero !== leader && hero.getMonsterTrophiesCount() > leader.getMonsterTrophiesCount()) {\n      leader = hero;\n    }\n  });\n  return leader;\n}\n\nexport const getMonsterTrophiesCountHeroesDiff = (leader, outsider) => {\n  return leader.getMonsterTrophiesCount() - outsider.getMonsterTrophiesCount();\n}","import { Y, B, G, R,  SHIFT_SCROLL, HEAL_POTION, RUNE } from '../const';\nimport { randomInt } from '../utils';\n\nconst MAX_SPELLS = 5;\nconst MIN_SPELLS = 4;\nconst START_SHIFT_SPELL_SCROLLS = 1;\nconst START_HEAL_POTION = 0;\nconst START_RUNES = 0;\n\n\nexport default class Hero {\n  constructor(name, spells) {\n    this.name = name;\n    this.spells = spells.slice(0, MAX_SPELLS).sort();\n    this.shiftSpellScrolls = START_SHIFT_SPELL_SCROLLS;\n    this.healPotions = START_HEAL_POTION;\n    this.runes = START_RUNES;\n    this.monsterTrophies = [];\n  }\n\n  getSpells() {\n    return [...this.spells];\n  }\n\n  getStrongestSpell() {\n    return [...this.spells].sort((a,b) =>\n    this.spells.filter(v => v===a).length - this.spells.filter(v => v===b).length\n    )[this.spells.length - 1];\n  }\n\n  useShiftSpellScroll() {\n    this.shiftSpellScrolls && this.shiftSpellScrolls--;\n  }\n\n  addShiftSpellScroll() {\n    this.shiftSpellScrolls++;\n  }\n\n  addHealPotion() {\n    if(this.spells.length < MAX_SPELLS) {\n      this.addRandomSpell();\n    } else {\n      this.healPotions++;\n    }\n  }\n\n  addRune() {\n    this.runes++;\n  }\n\n  useRunes(runesUsedCount) {\n    this.runes-=runesUsedCount;\n  }\n\n  hit() {\n    if(this.healPotions) {\n      this.useHealPotion();\n    } else if (this.spells.length > MIN_SPELLS) {\n      this.removeRandomSpell();\n    };\n  }\n\n  useHealPotion() {\n    this.healPotions && this.healPotions--;\n  }\n\n  removeRandomSpell() {\n    const spellIndex = this.spells[Math.floor(Math.random() * this.spells.length)];\n    this.spells.splice(spellIndex - 1, 1);\n  }\n\n  addRandomSpell() {\n    const possibleSpells = [Y, B, G, R];\n    // first try to add spell type missed in heroes spells list\n    const missedSpells = possibleSpells.filter(s => !this.spells.includes(s));\n    let spell;\n    if (missedSpells.length) {\n      spell = missedSpells.pop();\n    } else {\n      // otherwise add random spell\n      spell = possibleSpells[Math.floor(Math.random() * possibleSpells.length)];\n    }\n    this.spells.push(spell);\n  }\n\n  addMonsterTrophy(monster) {\n    this.monsterTrophies.push(monster);\n  }\n\n  getMonsterTrophiesCount() {\n    return this.monsterTrophies.length;\n  }\n\n  getMonsterTrophiesPoints() {\n    return this.monsterTrophies.reduce((acc, monster) => acc + monster.getStrength(), 0);\n  }\n\n  getTotalPoints() {\n    return this.getMonsterTrophiesPoints() + this.runes + this.healPotions + this.shiftSpellScrolls;\n  }\n\n  giveRandomTreasure() {\n    let treasureGift = [SHIFT_SCROLL, HEAL_POTION, RUNE][randomInt(3)];\n\n    if( this.spells.length < MAX_SPELLS) {\n      treasureGift = HEAL_POTION;\n    }\n\n    switch (treasureGift) {\n      case SHIFT_SCROLL:\n        this.addShiftSpellScroll();\n        break;\n      case HEAL_POTION:\n        this.addHealPotion();\n        break;\n      case RUNE:\n        this.addRune();\n        break;\n      default:\n        return;\n    }\n  }\n}","import { Y, B, G, R } from './const';\nimport Hero from './classes/hero';\n\nexport const hero1 = new Hero(\"Egemon\", [R,G,Y,B,Y]);\nexport const hero2 = new Hero(\"Alex\", [R,G,Y,B,B]);\nexport const hero3 = new Hero(\"Steve\", [R,G,Y,B,G]);\nexport const hero4 = new Hero(\"Amogus\", [R,G,Y,B,R]);\n\nexport const heroesArray = [hero1, hero2, hero3, hero4];\n","import React from 'react';\n\nexport default function TurnHero({hero, heroStatus}) {\n  const heroStrongestSpell = heroStatus ? heroStatus.strongestSpell : hero.getStrongestSpell();\n  const shiftSpellScrollsLeft = heroStatus ? heroStatus.shiftSpellScrollsLeft : hero.shiftSpellScrolls;\n  const runesLeft = heroStatus ? heroStatus.runesLeft : hero.runes;\n  const healPotionsLeft = heroStatus ? heroStatus.healPotionsLeft : hero.healPotions;\n  const spells = heroStatus ? heroStatus.spells : hero.spells;\n\n  return (\n    <div className=\"hero\">\n      <h3>{hero.name}</h3>\n      <div>Shifts Scrolls: <b>{shiftSpellScrollsLeft}</b></div>\n      <div>Runes: <b>{runesLeft}</b></div>\n      <div>Heal potions: <b>{healPotionsLeft}</b></div>\n      <div className=\"spells\">\n        {spells.map((spell, index) => <span key={index} className={`spell spell-${spell}`}>{spell}</span>)}\n      </div>\n      <span className=\"spells\">\n        Strongest: <span className={`spell spell-${heroStrongestSpell}`}>{heroStrongestSpell}</span>\n     </span>\n     <div className=\"monsterTrophies\">Monsters trophies: <b>{hero.getMonsterTrophiesCount()}/{hero.getMonsterTrophiesPoints()}</b><br/>\n     Total points: <b>{hero.getTotalPoints()}</b></div>\n    </div>\n  );\n};\n","import React from 'react';\n// import * as math from 'mathjs';\n\nexport default function BiomeMatrix({biome}) {\n  const biomeArr = biome.matrix.valueOf();\n\n  return (\n    <div className=\"biome-matrix\">\n      <div className=\"spells-matrix\">\n        {biomeArr.map((spellsRow, index) => <div key={index} className=\"spells\">{spellsRow.map((spell, index) => <span key={index} className={`spell spell-${spell}`}>{spell}</span>)}</div>)}\n      </div>\n    </div>\n  );\n};\n","import React from 'react';\n// import * as math from 'mathjs';\n\nexport default function MonsterMatrix({monsterSpellsMatrixOnBiome}) {\n  const monsterArr = monsterSpellsMatrixOnBiome.valueOf();\n\n  return (\n    <div className=\"monster-matrix\">\n      <div className=\"spells-matrix\">\n        {monsterArr.map((spellsRow, index) => <div key={index} className=\"spells\">{spellsRow.map((spell, index) => <span key={index} className={`spell spell-${spell}`}>{spell}</span>)}</div>)}\n      </div>\n    </div>\n  );\n};\n","import React from 'react';\n\nexport default function TurnPhaseFailureRecord({failureRecord}) {  \n  return (\n    <div className=\"failureRecord\">\n      <span className=\"label\">Failure diff:</span>\n      <div className=\"spells\">\n        {failureRecord.map(({spell, diff}) => <span key={spell} className={`spell spell-${spell} ${!diff && 'empty'}`}>{diff ? diff : ' '}</span>)}\n      </div>\n    </div>\n  );\n};\n","import React from 'react';\nimport { Y, B, G, R } from '../const';\n\nexport default function TurnPhaseShiftSpellUsed({shiftSpell}) {\n\n  function getCurrentShiftSpellFromArray(shiftSpell) {\n    switch (JSON.stringify(shiftSpell)) {\n      case '[-1,0]':\n        return Y;\n      case '[0,1]': \n        return B;\n      case '[1,0]':\n        return G;\n      case '[0,-1]':\n        return R;\n      default:\n        return false; \n    }\n  }\n\n  const spell = getCurrentShiftSpellFromArray(shiftSpell);\n\n  return (\n    <div className=\"shiftSpellUsed\">\n      <span className=\"label\">Shift scroll:</span>\n      <div className=\"spells\">\n        <span className={`spell spell-${spell}`}></span>\n      </div>\n    </div>\n  );\n};\n","import React from 'react';\nimport { Y, B, G, R } from '../const';\n\nexport default function TurnPhaseRuneUsed({runes}) {\n\n  // function getCurrentShiftSpellFromArray(runes) {\n  //   switch (JSON.stringify(shiftSpell)) {\n  //     case '[-1,0]':\n  //       return Y;\n  //     case '[0,1]': \n  //       return B;\n  //     case '[1,0]':\n  //       return G;\n  //     case '[0,-1]':\n  //       return R;\n  //     default:\n  //       return false; \n  //   }\n  // }\n\n  // const spell = getCurrentShiftSpellFromArray(runes);\n\n  return (\n    <div className=\"runeUsed\">\n      <span className=\"label\">Rune:</span>\n      <div className=\"spells\">\n        {runes.map(({spell}) =><span key={spell} className={`spell spell-${spell}`}></span> )}\n      </div>\n    </div>\n  );\n};\n","import React from 'react';\nimport TurnHero from './turn-hero';\nimport './turn.css';\nimport BiomeMatrix from './biome-matrix';\nimport MonsterMatrix from './monster-matrix';\nimport TurnPhaseFailureRecord from './turnPhaseFailureRecord';\nimport TurnPhaseShiftSpellUsed from './turnPhaseShiftSpellUsed';\nimport TurnPhaseRuneUsed from './turnPhaseRuneUsed';\n\nexport default function Turn({turnRecord}) {\n  // console.log(turnRecord);\n  if (!turnRecord.monster) {\n    return <div className=\"turn\">\n      <div className=\"treasure\">\n        {turnRecord.findShiftScroll && <span className=\"shiftSpell\">Shift spell scroll <br/><b>{turnRecord.heroStatus.shiftSpellScrollsLeft}</b></span>}\n        {turnRecord.findHealPotion && <span className=\"healPotion\">Heal potion<br/><b>{turnRecord.heroStatus.healPotionsLeft}</b></span>}\n        {turnRecord.findRune && <span className=\"rune\">Rune<br/><b>{turnRecord.heroStatus.runesLeft}</b></span>}\n      </div>\n    </div>\n  }\n  return (\n    <div className={`turn ${turnRecord.isSuccess ? 'isSuccess' : 'isFailure'}`}>\n      <div className=\"turnDescription\">\n        <TurnHero hero={turnRecord.hero} heroStatus={turnRecord.phases[0].heroStatus} />\n        vs\n        <span className=\"meetDetails\"><b>{turnRecord.monster.name}</b> on the <b>{turnRecord.biome.name}</b> biome</span>\n      </div>\n      <div className=\"turnContent\">\n        {turnRecord.phases.map((phase, index) => <div className=\"turnPhase\" key={index}>\n            <div className=\"monsterAndBiomeMatrixes\">\n              <BiomeMatrix biome={turnRecord.biome}/>\n              <MonsterMatrix monsterSpellsMatrixOnBiome={phase.monsterSpellsMatrixOnBiome}/>\n            </div>\n            {phase.shiftSpellWasUsed && <TurnPhaseShiftSpellUsed shiftSpell={phase.shiftSpell}/>}\n            {phase.runesWasUsed && <TurnPhaseRuneUsed runes={phase.runes}/>}\n            {phase.failureRecord && <TurnPhaseFailureRecord className=\"failureRecord\" failureRecord={phase.failureRecord}/>}\n        </div>)}\n      </div>\n    </div>\n  );\n};\n","\nimport { SHIFT_SCROLL, HEAL_POTION, RUNE, MONSTER } from './const';\nimport { monstersArray } from './monsters';\nimport { biomesArray } from './biomes';\nimport { heroesArray } from './heroes';\n\nimport { fightWithMonster, fightWithMonsterUsingSpellsTestAllDirections, fightWithMonsterUsingRunes, getCurrenHeroStatus, getMonsterWithShiftedMatrix, randomInt, randomWeighted, getFailedSpellsCount, getMonsterTrophiesCountOutsiderHero, getMonsterTrophiesCountLeaderHero, getMonsterTrophiesCountHeroesDiff } from './utils';\n\nimport Turn from './components/turn';\nimport TurnHero from './components/turn-hero';\n\nconst turnRecords = window.turnRecords = [];\n\n\nconst attackMonster = ({hero, monster, biome, turnRecord}) => {\n  let currentMonster = monster;\n  let fightResult = fightWithMonster({ hero, monster, biome });\n  turnRecord.phases.push(fightResult);\n\n  if (!fightResult.isSuccess && hero.shiftSpellScrolls) {\n    fightResult = fightWithMonsterUsingSpellsTestAllDirections({ hero, monster: currentMonster, biome, prevFightResult: fightResult });\n    currentMonster = getMonsterWithShiftedMatrix(currentMonster, fightResult.shiftSpell);\n    turnRecord.phases.push(fightResult);\n    if (!fightResult.isSuccess && fightResult.shiftSpell && hero.shiftSpellScrolls &&!!randomWeighted({0: .4, 1: .6})) {\n      fightResult = fightWithMonsterUsingSpellsTestAllDirections({ hero, monster: currentMonster, biome, prevFightResult: fightResult });\n      currentMonster = getMonsterWithShiftedMatrix(currentMonster, fightResult.shiftSpell);\n      turnRecord.phases.push(fightResult);\n    }\n  }\n\n  if (!fightResult.isSuccess && hero.runes >= getFailedSpellsCount(fightResult)) {\n    // console.log({hero});\n    fightResult = fightWithMonsterUsingRunes({ hero, monster: currentMonster, biome, prevFightResult: fightResult });\n    // console.log({fightResult});\n    turnRecord.phases.push(fightResult);\n  }\n\n  turnRecord.isSuccess = fightResult.isSuccess;\n  if (fightResult.isSuccess) {\n    hero.addMonsterTrophy(monster);\n  } else {\n    hero.hit();\n  }\n}\n\n\nconst heroTurn = ({hero, biome}) => {\n  const turnRecord = {\n    key: Math.random(),\n    hero,\n    biome,\n    phases: [],\n  };\n\n  const possibleEncounters = [MONSTER, SHIFT_SCROLL, HEAL_POTION, RUNE];\n  const currentEncounter = possibleEncounters[randomWeighted({0: .6, 1: .2, 2: .1, 3: .1})];\n\n  if(currentEncounter === MONSTER) {\n    const monster = monstersArray[Math.floor(Math.random() * monstersArray.length)];\n    turnRecord.monster = monster;\n    attackMonster({hero, monster, biome, turnRecord});\n  } else if (currentEncounter === SHIFT_SCROLL) {\n    turnRecord.findShiftScroll = true;\n    hero.addShiftSpellScroll();\n  } else if (currentEncounter === HEAL_POTION) {\n    turnRecord.findHealPotion = true;\n    hero.addHealPotion();\n  } else if (currentEncounter === RUNE) {\n    turnRecord.findRune = true;\n    hero.addRune();\n  }\n\n  return {\n    ...turnRecord,\n    heroStatus: getCurrenHeroStatus(hero)\n  };\n}\n\n\n\n\n  // const biome = biomesArray[0].matrix;\n  // const monster = monstersArray[2].matrix;\n  // const heroSpells = heroesArray[0].spells;\n  // const monsterSpells = monstersArray[0].matrix;\n  // const biomeSpells = biomesArray[0].matrix;\n\n  // heroTurn({hero: heroesArray[0], biome: biomesArray[3]});\n  // heroTurn({hero: heroesArray[0], biome: biomesArray[1]});\n  // heroTurn({hero: heroesArray[2], biome: biomesArray[2]});\n  // heroTurn({hero: heroesArray[2], biome: biomesArray[3]});\n  \n  // heroesArray.forEach((hero, index) => {\n  //   console.groupCollapsed(`Hero ${index}`);\n  //   biomesArray.forEach(biome => {\n  //     heroTurn({hero, biome});\n  //     heroTurn({hero, biome});\n  //     console.log({hero});\n  //   })\n  //   console.groupEnd();\n  //   console.log('-', {\n  //     wins: turnRecords.filter(t=>t.hero === hero).filter(x=> x.monster && x.isSuccess),\n  //     fails: turnRecords.filter(t=>t.hero === hero).filter(x=> x.monster && !x.isSuccess),\n  //     scrolls: turnRecords.filter(t=>t.hero === hero).filter(x=> !x.monster),\n  //     // shiftSpellUseCount,\n  //     // fightResultsArray,\n  //     // spellComparisonFailuresArray,\n  //   });\n  //   // shiftSpellUseCount = 0;\n  //   // fightResultsArray = [];\n  //   // spellComparisonFailuresArray = [];\n  // })\n\n  const roundsCount = 10;\n  for (let index = 0; index < roundsCount; index++) {\n    const outsiderHero = getMonsterTrophiesCountOutsiderHero(heroesArray);\n    const leaderHero = getMonsterTrophiesCountLeaderHero(heroesArray);\n    if(getMonsterTrophiesCountHeroesDiff(leaderHero, outsiderHero) >= 2) {\n      // outsiderHero.giveRandomTreasure();\n    }\n\n    heroesArray.forEach((hero) => {\n      const prefferableBiomeType = hero.getStrongestSpell();\n      const prefferableBiome = biomesArray.find(b => b.type === prefferableBiomeType);\n      const randomBiome = biomesArray[randomInt(biomesArray.length)];\n      let currentBiome = [prefferableBiome, randomBiome][randomWeighted({0: .8, 1: .2})];\n      // if(!(index && index % 4)) { // every 4-th eteration add a tile to the biome\n      //   heroTurn({hero, biome: currentBiome});\n      // }\n\n      if(hero === outsiderHero) {\n        currentBiome = randomBiome;\n        turnRecords.push([\n          heroTurn({hero, biome: currentBiome}),\n          heroTurn({hero, biome: currentBiome})\n        ]);\n      } else {\n        turnRecords.push(heroTurn({hero, biome: currentBiome}))\n      }\n    })\n  }\n\n  // console.log('-', {\n  //   wins: fightResultsArray.filter(x => x).length,\n  //   fails: fightResultsArray.filter(x => !x).length,\n  //   shiftSpellUseCount,\n  //   fightResultsArray,\n  //   spellComparisonFailuresArray,\n  // });\n\n  const turnRecordsByHero = turnRecords.reduce((acc, turn) => {\n    const { name } = turn.hero || turn[0].hero;\n    if (!acc[name]) {\n      acc[name] = [];\n    }\n    acc[name].push(turn);\n    return acc;\n  }, {});\n\n  console.log({turnRecordsByHero});\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <h2>The Spells shifters game</h2>\n      <div className=\"heroesRecords final\">\n        {Object.entries(turnRecordsByHero).map(([key, value]) => <div className=\"heroRecords\" key={key}>\n          <TurnHero hero={value[0].hero || value[0][0].hero} />\n        </div>)}\n      </div>\n        <hr />\n      {/* {turnRecords.map(turnRecord => <Turn key={turnRecord.key} turnRecord={turnRecord} />)} */}\n      <div className=\"heroesRecords\">\n        {Object.entries(turnRecordsByHero).map(([key, value]) => <div className=\"heroRecords\" key={key}>\n          <h3>{key}</h3>\n          {value.map((turnRecord, index ) => {\n            return Array.isArray(turnRecord)\n              ? <div className=\"doubleTurn\" key={index}>\n                  {turnRecord.map(turnRecordInner => {\n                    return <Turn key={turnRecordInner.key} turnRecord={turnRecordInner} />\n                  })}\n                </div>\n              : <Turn key={turnRecord.key} turnRecord={turnRecord} />\n          })}\n        </div>)}\n      </div>\n      \n      \n    </div>\n  );\n}\nconsole.log('-------');\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}